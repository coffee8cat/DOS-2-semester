Turbo Assembler	 Version 4.1	    02/23/25 10:21:19	    Page 1
interr~1.asm



      1	    0000			 .model	tiny
      2	    0000			 .code
      3					 .386
      4					 org 100h
      5					 locals	@@
      6
      7	    0100			 Start:
      8
      9					 ; Rewriting INT09H in Table of								    +
     10					 Interruptions-----------------------------------------------------------
     11
     12					     ; set es[bx] to a INT09H pointer
     13	    0100  33 C0				 xor ax, ax
     14	    0102  8E C0				 mov es, ax
     15	    0104  B9 1234			 mov cx, 1234h
     16	    0107  BA 5678			 mov dx, 5678h
     17	    010A  BB 0024			 mov bx, 09h * 04h
     18
     19					     ; Save old	handler	of INT09H
     20	    010D  26: 8B 07			 mov ax, es:[bx]
     21	    0110  A3 01A1r			 mov word ptr old_int9_ofs, ax
     22	    0113  26: 8B 47 02			 mov ax, es:[bx+2]
     23	    0117  A3 01A3r			 mov word ptr old_int9_seg, ax
     24
     25					     ; write new handler for INT09H
     26					     ; Forbid interrupts to avoid trying to handle interruption	with wrong function address
     27	    011A  FA				 cli
     28	    011B  26: C7 07 0154r		 mov es:[bx], offset INT09H_StandIn
*Warning* interr~1.asm(27) Argument needs type override
     29	    0120  0E				 push cs
     30	    0121  58				 pop ax
     31	    0122  26: 89 47 02			 mov es:[bx+2],	ax
     32	    0126  FB				 sti
     33
     34						 ;int 09h
     35					 ; Rewriting INT08H in Table of								    +
     36					 Interruptions-----------------------------------------------------------
     37
     38					     ; set es[bx] to a INT08H pointer
     39	    0127  33 C0				 xor ax, ax
     40	    0129  8E C0				 mov es, ax
     41	    012B  BB 0020			 mov bx, 08h * 04h
     42
     43					     ; Save old	handler	of INT08H
     44	    012E  26: 8B 07			 mov ax, es:[bx]
     45	    0131  A3 020Br			 mov word ptr old_int8_ofs, ax
     46	    0134  26: 8B 47 02			 mov ax, es:[bx+2]
     47	    0138  A3 020Dr			 mov word ptr old_int8_seg, ax
     48
     49					     ; write new handler for INT08H
     50					     ; Forbid interrupts to avoid trying to handle interruption	with wrong function address
     51	    013B  FA				 cli
     52	    013C  26: C7 07 01A8r		 mov es:[bx], offset INT08H_StandIn
*Warning* interr~1.asm(50) Argument needs type override
     53	    0141  0E				 push cs
     54	    0142  58				 pop ax
     55	    0143  26: 89 47 02			 mov es:[bx+2],	ax
Turbo Assembler	 Version 4.1	    02/23/25 10:21:19	    Page 2
interr~1.asm



     56	    0147  FB				 sti
     57
     58					 ; Terminate and Stay									    +
     59					 Resident--------------------------------------------------------------------------
     60	    0148  B8 3100			 mov ax, 3100h		 ; TSR
     61	    014B  BA 0318r			 mov dx, offset	EOP	 ; programm size in paragraphs (16 byte)
     62	    014E  C1 EA	04			 shr dx, 4
     63	    0151  42				 inc dx
     64	    0152  CD 21				 int 21h
     65
     66					 ;===========================================================================================
     67					 ==================
     68					 ; Called from INT09H, draws frame to display registers	values (frame active) if interruption
     69					 ; caused by pressing [R]. Erases frame	on second press	of [R].
     70					 ; At the end of function jumps	to original INT09H handler
     71					 ; Entry:    None
     72					 ; Exit:     None
     73					 ; Destr:    al
     74					 ;===========================================================================================
     75					 ==================
     76	    0154			 INT09H_StandIn	 proc
     77
     78		  =0013			 R_scan_code equ 013h
     79
     80	    0154  06				 push es
     81	    0155  57				 push di
     82
     83	    0156  52				 push dx
     84	    0157  51				 push cx
     85	    0158  53				 push bx
     86	    0159  50				 push ax
     87
     88	    015A  BB B800 90			 mov bx, VideoMemSegment     ; set es to the beginnig of video mem segment
     89	    015E  8E C3				 mov es, bx
     90	    0160  B4 03				 mov ah, 03h
     91
     92					 ; if (scan_code != scan_code(R)) { jmp	to old INT09H handler}
     93	    0162  E4 60				 in al,	60h	 ; load	key scan code
     94
     95	    0164  3C 13				 cmp al, R_scan_code
     96	    0166  75 32	90 90			 jne end_INT09H_StandIn
     97
     98					 ; if (Active == 1) { erase frame, Active = 0} else { Make frame, Active = 1}
     99	    016A  80 3E	01A7r 00		 cmp byte ptr Frame_Active, 0b
    100	    016F  74 21	90 90			 je  @@not_Active
    101
    102					 ; Frame is active, erase frame
    103
    104
    105	    0173  BB B800 90			 mov bx, VideoMemSegment     ; set es to the beginnig of video mem segment
    106	    0177  8E C3				 mov es, bx
    107
    108	    0179  B9 0009			 mov cx, 09h
    109	    017C  BA 0006			 mov dx, 06h
    110
    111	    017F  E8 00E5			 call CalcFrameStart
    112
Turbo Assembler	 Version 4.1	    02/23/25 10:21:19	    Page 3
interr~1.asm



    113	    0182  BE 024Dr			 mov si, offset	Sequence + 9
    114	    0185  B4 03				 mov ah, 03h
    115
    116	    0187  E8 00FE			 call DrawFrame
    117
    118	    018A  C6 06	01A7r 00		 mov byte ptr Frame_Active, 0b
    119	    018F  EB 09	90			 jmp end_INT09H_StandIn
    120
    121	    0192			 @@not_Active:
    122
    123	    0192  E8 007A			 call MakeFrame
    124	    0195  C6 06	01A7r 01		 mov byte ptr Frame_active, 1b
    125
    126	    019A			 end_INT09H_StandIn:
    127
    128	    019A  58				 pop ax
    129	    019B  5B				 pop bx
    130	    019C  59				 pop cx
    131	    019D  5A				 pop dx
    132
    133	    019E  5F				 pop di
    134	    019F  07				 pop es
    135
    136	    01A0  EA					 db 0eah     ; jmp code
    137	    01A1  0000			 old_int9_ofs:	 dw 0
    138	    01A3  0000			 old_int9_seg:	 dw 0
    139
    140	    01A5  00 00			 RegValuesOff:	 db 0h,	0h   ; start position in VideoMemSeg for writing registers values
    141
    142	    01A7  00			 Frame_Active:	 db 0
    143	    01A8				 endp
    144					 ;===========================================================================================
    145					 ==================
    146					 ; Called from INT08H, displays	registers values if frame is active.
    147					 ; At the end of function jumps	to original INT08H handler
    148					 ; Entry:    None
    149					 ; Exit:     None
    150					 ; Destr:    al
    151					 ;===========================================================================================
    152					 ==================
    153	    01A8			 INT08H_StandIn	 proc
    154
    155	    01A8  06				 push es
    156	    01A9  57				 push di
    157
    158	    01AA  52				 push dx
    159	    01AB  51				 push cx
    160	    01AC  53				 push bx
    161	    01AD  50				 push ax
    162
    163	    01AE  BB B800 90			 mov bx, VideoMemSegment     ; set es to the beginnig of video mem segment
    164	    01B2  8E C3				 mov es, bx
    165
    166	    01B4  80 3E	01A7r 01		 cmp byte ptr Frame_Active, 1b
    167	    01B9  75 49	90 90			 jne @@end_INT08H_StandIn
    168
    169
Turbo Assembler	 Version 4.1	    02/23/25 10:21:19	    Page 4
interr~1.asm



    170					 ; Displaying registers	values------------------------------
    171
    172	    01BD  BB 0242r			 mov bx, offset	DI_stored
    173	    01C0  2E: 8B 3F			 mov word ptr di, cs:[bx]
    174
    175	    01C3  83 C7	0E			 add di, 0Eh	 ; 8 + 6
    176	    01C6  8B DC				 mov bx, sp
    177
    178	    01C8  83 C3	02			 add bx, 02h
    179	    01CB  36: 8B 07			 mov ax, word ptr ss:[bx]
    180	    01CE  81 C7	00A0			 add di, 0A0h
    181
    182	    01D2  53				 push bx
    183	    01D3  E8 0106			 call itoa_hex
    184	    01D6  5B				 pop bx
    185
    186	    01D7  83 C3	02			 add bx, 02h
    187	    01DA  36: 8B 07			 mov ax, word ptr ss:[bx]
    188	    01DD  81 C7	00A0			 add di, 0A0h
    189
    190	    01E1  53				 push bx
    191	    01E2  E8 00F7			 call itoa_hex
    192	    01E5  5B				 pop bx
    193
    194	    01E6  83 C3	02			 add bx, 02h
    195	    01E9  36: 8B 07			 mov ax, word ptr ss:[bx]
    196	    01EC  81 C7	00A0			 add di, 0A0h
    197
    198	    01F0  53				 push bx
    199	    01F1  E8 00E8			 call itoa_hex
    200	    01F4  5B				 pop bx
    201
    202	    01F5  83 C3	02			 add bx, 02h
    203	    01F8  36: 8B 07			 mov ax, word ptr ss:[bx]
    204	    01FB  81 C7	00A0			 add di, 0A0h
    205
    206	    01FF  53				 push bx
    207	    0200  E8 00D9			 call itoa_hex
    208	    0203  5B				 pop bx
    209
    210	    0204			 @@end_INT08H_StandIn:
    211
    212	    0204  58				 pop ax
    213	    0205  5B				 pop bx
    214	    0206  59				 pop cx
    215	    0207  5A				 pop dx
    216
    217	    0208  5F				 pop di
    218	    0209  07				 pop es
    219
    220	    020A  EA					 db 0eah     ; jmp code
    221	    020B  0000			 old_int8_ofs:	 dw 0
    222	    020D  0000			 old_int8_seg:	 dw 0
    223
    224	    020F				 endp
    225
    226					 ;===========================================================================================
Turbo Assembler	 Version 4.1	    02/23/25 10:21:19	    Page 5
interr~1.asm



    227					 ==================
    228					 ; Makes a frame for displaying	registers values
    229					 ;
    230					 ;
    231					 ;
    232					 ;		 NOT VALID DESCRIPTION
    233					 ;
    234					 ;
    235
    236					 ; Entry:    cx	- length of the	frame
    237					 ;	     dx	- height of the	frame
    238					 ; Exit:     di	- pointer to a start position
    239					 ; Destr:    ax
    240					 ;===========================================================================================
    241					 ==================
    242	    020F			 MakeFrame   proc
    243
    244	    020F  BB B800 90			 mov bx, VideoMemSegment     ; set es to the beginnig of video mem segment
    245	    0213  8E C3				 mov es, bx
    246
    247					 ; Drawing Frame--------------------------------------------
    248
    249	    0215  B9 0009			 mov cx, 09h
    250	    0218  BA 0006			 mov dx, 06h
    251
    252	    021B  E8 0049			 call CalcFrameStart
    253
    254	    021E  2E: 89 3E 0242r		 mov word ptr cs:[offset DI_stored], di
    255
    256	    0223  57				 push di
    257
    258	    0224  BE 0244r			 mov si, offset	Sequence
    259	    0227  B4 03				 mov ah, 03h
    260
    261	    0229  E8 005C			 call DrawFrame
    262
    263	    022C  5F				 pop di		 ; saved start position	of frame (left upper edge)
    264
    265					 ; Write registers names------------------------------------
    266
    267	    022D  57				 push di
    268
    269						 ; di will be shifted to the begining of the first string for first WriteString
    270	    022E  83 C7	08			 add di, 08h
    271	    0231  BE 0256r			 mov si, offset	RegName
    272
    273	    0234			 @@loop:
    274	    0234  81 C7	009A			 add di, 09Ah		 ; considering length_of_strings = 3, di_shift = 160 - 3 * 2
    275	    0238  E8 008C			 call WriteString
    276
    277	    023B  2E: 38 0C			 cmp cs:[si], cl	 ; after WriteString 0Dh stored	in cl
    278	    023E  75 F4				 jne @@loop		 ; writing strings until '0Dh',	'0Dh' is met
    279
    280	    0240  5F				 pop di
    281
    282	    0241  C3				 ret
    283	    0242				 endp
Turbo Assembler	 Version 4.1	    02/23/25 10:21:19	    Page 6
interr~1.asm



    284
    285	    0242  0000			 DI_stored: dw 0
    286
    287
    288	    0244  C9 CD	BB BA 20 BA C8+	 Sequence:   db	 0c9h, 0cdh, 0bbh, 0bah, 020h, 0bah, 0c8h, 0cdh, 0bch	 ; double line box
    289		  CD BC
    290	    024D  20 20	20 20 20 20 20+		     db	 020h, 020h, 020h, 020h, 020h, 020h, 020h, 020h, 020h	 ; empty black space
    291		  20 20
    292
    293	    0256  61 78	3A 0D 62 78 3A+	 RegName:    db	 'ax:',	0Dh, 'bx:', 0Dh, 'cx:',	0Dh, 'dx:', 0Dh, 0Dh
    294		  0D 63	78 3A 0D 64 78+
    295		  3A 0D	0D
    296
    297					 ;===========================================================================================
    298					 ==================
    299					 ; Calculates the start	position for a frame in	video mem
    300					 ; Entry:    cx	- length of the	frame
    301					 ;	     dx	- height of the	frame
    302					 ; Exit:     di	- pointer to a start position
    303					 ; Destr:    ax
    304					 ;===========================================================================================
    305					 ==================
    306	    0267			 CalcFrameStart	 proc
    307
    308	    0267  51				 push cx
    309	    0268  52				 push dx
    310	    0269  8B C2				 mov ax, dx
    311
    312						 ; di =	(80 - cx / 2 + 160 * (14 - dx /	2)) / 2	* 2
    313	    026B  D1 E8				 shr ax, 1
    314
    315	    026D  BF 0050			 mov di, 0050h
    316	    0270  2B F9				 sub di, cx
    317
    318	    0272  2D 000E			 sub ax, 0Eh
    319	    0275  F7 D8				 neg ax
    320	    0277  C1 E0	05			 shl ax, 5
    321
    322	    027A  B9 0005			 mov cx, 05h
    323	    027D  F7 E1				 mul cx
    324
    325	    027F  03 F8				 add di, ax
    326
    327	    0281  D1 EF				 shr di, 1		 ; round to a multiple of 2
    328	    0283  D1 E7				 shl di, 1
    329
    330	    0285  5A				 pop dx
    331	    0286  59				 pop cx
    332
    333	    0287  C3				 ret
    334	    0288				 endp
    335
    336
    337					 ;===========================================================================================
    338					 ==================
    339					 ; Draws a frame in video mem described	with 9 bytes
    340					 ; Entry:    ah	- color
Turbo Assembler	 Version 4.1	    02/23/25 10:21:19	    Page 7
interr~1.asm



    341					 ;	     si	- pointer to 9 byte sequence
    342					 ;	     cx	- length of the	frame
    343					 ;	     dx	- height of the	frame
    344					 ; Exit:     None
    345					 ; Destr:    al, si, di
    346					 ;===========================================================================================
    347					 ==================
    348	    0288			 DrawFrame   proc
    349
    350	    0288  52				 push dx
    351	    0289  1E				 push ds
    352	    028A  8C CB				 mov bx, cs
    353	    028C  8E DB				 mov ds, bx
    354
    355	    028E  E8 001D			 call DrawLine
    356	    0291  83 C6	03			 add si, 03h		 ; move	to the next subsequence
    357
    358	    0294  FE CA				 dec dl
    359	    0296  FE CA				 dec dl
    360	    0298			 height:
    361	    0298  E8 0013			 call DrawLine
    362	    029B  FE CA				 dec dl
    363	    029D  80 FA	00			 cmp dl, 0h
    364	    02A0  77 F6				 ja height
    365
    366	    02A2  83 C6	03			 add si, 03h
    367
    368	    02A5  E8 0006			 call DrawLine
    369	    02A8  83 C6	03			 add si, 03h
    370
    371	    02AB  1F				 pop ds
    372	    02AC  5A				 pop dx
    373
    374	    02AD  C3				 ret
    375	    02AE				 endp
    376
    377					 ;===========================================================================================
    378					 ==================
    379					 ; Draws line described	with 3 bytes in	video mem
    380					 ; 1 time first	byte, (cx-2) times - second byte and then third	byte
    381					 ; 121 (cx = 6)	=> 122221
    382					 ; Entry:    ah	- color
    383					 ;	     si	- pointer to 3 byte sequence
    384					 ;	     cx	- length of the	frame
    385					 ; Exit:     None
    386					 ; Destr:    al, di
    387					 ;===========================================================================================
    388					 ==================
    389	    02AE			 DrawLine    proc
    390
    391	    02AE  56				 push si	 ; save	si
    392	    02AF  51				 push cx	 ; save	cx
    393
    394	    02B0  49				 dec cx
    395	    02B1  49				 dec cx
    396
    397	    02B2  FC				 cld
Turbo Assembler	 Version 4.1	    02/23/25 10:21:19	    Page 8
interr~1.asm



    398	    02B3  AC				 lodsb		 ; reading first byte of sequance to al
    399	    02B4  AB				 stosw		 ; writing to video mem
    400
    401	    02B5  AC				 lodsb		 ; reading second byte
    402	    02B6  F3> AB			 rep stosw	 ; writing (cx - 2) times to video mem
    403
    404	    02B8  AC				 lodsb		 ; reading first byte of sequance to al
    405	    02B9  AB				 stosw		 ; writing to video mem
    406
    407	    02BA  59				 pop cx		 ; save	cx
    408
    409	    02BB  D1 E1				 shl cx, 1	 ; shift di to the beginning of	the next string
    410	    02BD  81 C7	00A0			 add di, 0A0h
    411	    02C1  2B F9				 sub di, cx
    412	    02C3  D1 E9				 shr cx, 1
    413
    414	    02C5  5E				 pop si		 ; save	si
    415
    416	    02C6  C3				 ret
    417	    02C7				 endp
    418
    419					 ;===========================================================================================
    420					 ==================
    421					 ; Writes a string ending with '\r' in video mem (could	be set in cl - look in func)
    422					 ; Entry:    ah	- color
    423					 ;	     si	- pointer to a string
    424					 ;	     di	- pointer to video mem for beginning of	the string
    425					 ; Exit:     None
    426					 ; Destr:    cx, si, di
    427					 ;===========================================================================================
    428					 ==================
    429	    02C7			 WriteString proc
    430
    431	    02C7  1E				 push ds
    432	    02C8  8C CB				 mov bx, cs
    433	    02CA  8E DB				 mov ds, bx
    434
    435	    02CC  B1 0D				 mov cl, 0Dh		 ; TERMINATING SYMBOL
    436
    437	    02CE			 @@test_condition:
    438	    02CE  2E: 38 0C			 cmp cs:[si], cl	 ; while (ds:[si] != cl)
    439	    02D1  74 06	90 90			 je while_end
    440
    441	    02D5  AC				 lodsb			 ; al =	ds:[si++]
    442	    02D6  AB				 stosw			 ; es:[di] = ax, di+=2
    443	    02D7  EB F5				 jmp @@test_condition
    444
    445	    02D9			 while_end:
    446
    447	    02D9  46				 inc si
    448	    02DA  1F				 pop ds
    449
    450	    02DB  C3				 ret
    451	    02DC				 endp
    452
    453					 ;===========================================================================================
    454					 ==================
Turbo Assembler	 Version 4.1	    02/23/25 10:21:19	    Page 9
interr~1.asm



    455					 ; Reads 16-based number from 0	to 255 from a string and saves to al
    456					 ; Entry:    di	- pointer to a string to write a number
    457					 ;	     ax	- value	to translate
    458					 ; Exit:     None
    459					 ; Destr:    di, si, ax, bx, cx
    460					 ;===========================================================================================
    461					 ==================
    462	    02DC			 itoa_hex    proc
    463
    464	    02DC  57				 push di
    465
    466						 ; bx =	ax // 16
    467						 ; for (i =0; i	< 4; i++) { es:[di] = ax % 16, ax = ax // 16}
    468
    469	    02DD  33 C9				 xor cx, cx
    470	    02DF  BE 0308r			 mov si, offset	HexASCII
    471
    472	    02E2			 @@for_cond_check:
    473
    474	    02E2  83 F9	04			 cmp cx, 04h
    475	    02E5  74 1F	90 90			 je  @@for_end
    476
    477	    02E9  8B D8				 mov bx, ax
    478	    02EB  C1 EB	04			 shr bx, 4
    479	    02EE  C1 E3	04			 shl bx, 4
    480
    481	    02F1  56				 push si
    482
    483	    02F2  03 F0				 add si, ax
    484	    02F4  2B F3				 sub si, bx
    485
    486	    02F6  2B C3				 sub ax, bx
    487	    02F8  2E: 8A 04			 mov byte ptr al, cs:[si]
    488	    02FB  26: 88 05			 mov byte ptr es:[di], al
    489	    02FE  4F				 dec di
    490	    02FF  4F				 dec di
    491	    0300  5E				 pop si
    492
    493	    0301  41				 inc cx
    494	    0302  8B C3				 mov ax, bx
    495	    0304  EB DC				 jmp @@for_cond_check
    496
    497	    0306			 @@for_end:
    498
    499	    0306  5F				 pop di
    500
    501	    0307  C3				 ret
    502	    0308				 endp
    503
    504
    505	    0308  30 31	32 33 34 35 36+	 HexASCII:   db	'0', '1', '2', '3', '4', '5', '6', '7'
    506		  37
    507	    0310  38 39	41 42 43 44 45+		     db	'8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
    508		  46
    509
    510		  =B800			 VideoMemSegment equ	 0b800h
    511
Turbo Assembler	 Version 4.1	    02/23/25 10:21:19	    Page 10
interr~1.asm



    512	    0318  00			 EOP:	 db 0
    513					 end	 Start
Turbo Assembler	 Version 4.1	    02/23/25 10:21:19	    Page 11
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "02/23/25"
??FILENAME			  Text	 "interr~1"
??TIME				  Text	 "10:21:19"
??VERSION			  Number 040A
@32BIT				  Text	 0
@@END_INT08H_STANDIN		  Near	 DGROUP:0204
@@FOR_COND_CHECK		  Near	 DGROUP:02E2
@@FOR_END			  Near	 DGROUP:0306
@@LOOP				  Near	 DGROUP:0234
@@NOT_ACTIVE			  Near	 DGROUP:0192
@@TEST_CONDITION		  Near	 DGROUP:02CE
@CODE				  Text	 DGROUP
@CODESIZE			  Text	 0
@CPU				  Text	 0F0FH
@CURSEG				  Text	 _TEXT
@DATA				  Text	 DGROUP
@DATASIZE			  Text	 0
@FILENAME			  Text	 INTERR~1
@INTERFACE			  Text	 000H
@MODEL				  Text	 1
@STACK				  Text	 DGROUP
@WORDSIZE			  Text	 4
CALCFRAMESTART			  Near	 DGROUP:0267
DI_STORED			  Near	 DGROUP:0242
DRAWFRAME			  Near	 DGROUP:0288
DRAWLINE			  Near	 DGROUP:02AE
END_INT09H_STANDIN		  Near	 DGROUP:019A
EOP				  Near	 DGROUP:0318
FRAME_ACTIVE			  Near	 DGROUP:01A7
HEIGHT				  Near	 DGROUP:0298
HEXASCII			  Near	 DGROUP:0308
INT08H_STANDIN			  Near	 DGROUP:01A8
INT09H_STANDIN			  Near	 DGROUP:0154
ITOA_HEX			  Near	 DGROUP:02DC
MAKEFRAME			  Near	 DGROUP:020F
OLD_INT8_OFS			  Near	 DGROUP:020B
OLD_INT8_SEG			  Near	 DGROUP:020D
OLD_INT9_OFS			  Near	 DGROUP:01A1
OLD_INT9_SEG			  Near	 DGROUP:01A3
REGNAME				  Near	 DGROUP:0256
REGVALUESOFF			  Near	 DGROUP:01A5
R_SCAN_CODE			  Number 0013
SEQUENCE			  Near	 DGROUP:0244
START				  Near	 DGROUP:0100
VIDEOMEMSEGMENT			  Number B800
WHILE_END			  Near	 DGROUP:02D9
WRITESTRING			  Near	 DGROUP:02C7

Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  _DATA				  16  0000 Word	  Public  DATA
  _TEXT				  16  0319 Word	  Public  CODE
Turbo Assembler	 Version 4.1	    02/23/25 10:21:19	    Page 12
Error Summary



*Warning* interr~1.asm(27) Argument needs type override
*Warning* interr~1.asm(50) Argument needs type override
