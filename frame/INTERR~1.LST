Turbo Assembler	 Version 4.1	    02/27/25 14:57:37	    Page 1
interr~1.asm



      1	    0000			 .model	tiny
      2	    0000			 .code
      3					 .386
      4					 org 100h
      5					 locals	@@
      6
      7	    0100  E8 01F5		 Start:		 call Main
      8
      9		  =B800			 VideoMemSegment equ	 0b800h
     10
     11		  =0003			 FrameColor	 equ	 03h
     12		  =0009			 FrameLength	 equ	 09h
     13		  =000F			 FrameHeight	 equ	 0Fh
     14
     15		  =000D			 DisplayedRegNum equ	 0Dh
     16		  =0002			 RegSize	 equ	 02h
     17
     18		  = db 0eah		 JMP_code	 equ	 db 0eah
     19
     20		  =0060			 KeyboardPort	 equ	 60h
     21
     22					 ;===========================================================================================
     23					 ==================
     24					 ; Called from INT09H, draws frame to display registers	values (frame active) if interruption
     25					 ; caused by pressing [R]. Erases frame	on second press	of [R].
     26					 ; At the end of function jumps	to original INT09H handler
     27					 ; Entry:    None
     28					 ; Exit:     None
     29					 ; Destr:    al
     30					 ;===========================================================================================
     31					 ==================
     32	    0103			 INT09H_StandIn	 proc
     33
     34		  =0013			 R_scan_code equ 013h
     35
     36	    0103  50				 push ax
     37	    0104  53				 push bx
     38	    0105  06				 push es
     39
     40					 ; if (scan_code != scan_code(R)) { jmp	to old INT09H handler}
     41	    0106  E4 60				 in al,	KeyboardPort		 ; load	key scan code
     42
     43	    0108  3C 13				 cmp al, R_scan_code
     44	    010A  75 20	90 90			 jne end_INT09H_StandIn
     45
     46
     47					 ; if (Active == 1) { erase frame, Active = 0} else { Make frame, Active = 1}
     48	    010E  80 3E	0134r 00		 cmp byte ptr Frame_Active, 0b
     49	    0113  74 12	90 90			 je  @@not_Active
     50
     51					 ; Frame is active, erase frame
     52
     53	    0117  BB B800			 mov bx, VideoMemSegment     ; set es to the beginnig of video mem segment
     54	    011A  8E C3				 mov es, bx
     55
     56	    011C  E8 0098			 call EraseFrame
     57
Turbo Assembler	 Version 4.1	    02/27/25 14:57:37	    Page 2
interr~1.asm



     58	    011F  C6 06	0134r 00		 mov byte ptr Frame_Active, 0b
     59	    0124  EB 06	90			 jmp end_INT09H_StandIn
     60
     61	    0127			 @@not_Active:
     62	    0127  C6 06	0134r 01		 mov byte ptr Frame_active, 1b
     63
     64	    012C			 end_INT09H_StandIn:
     65
     66	    012C  07				 pop es
     67	    012D  5B				 pop bx
     68	    012E  58				 pop ax
     69
     70	    012F  EA				 JMP_code
     71	    0130  0000			 old_int9_ofs:	 dw 0
     72	    0132  0000			 old_int9_seg:	 dw 0
     73
     74	    0134  00			 Frame_Active:	 db 0
     75	    0135				 endp
     76					 ;===========================================================================================
     77					 ==================
     78					 ; Called from INT08H, displays	registers values if frame is active.
     79					 ; At the end of function jumps	to original INT08H handler
     80					 ; Entry:    None
     81					 ; Exit:     None
     82					 ; Destr:    al
     83					 ;===========================================================================================
     84					 ==================
     85	    0135			 INT08H_StandIn	 proc
     86
     87	    0135  16				 push ss
     88	    0136  06				 push es
     89	    0137  1E				 push ds
     90	    0138  54				 push sp
     91
     92	    0139  55				 push bp
     93	    013A  57				 push di
     94	    013B  56				 push si
     95	    013C  52				 push dx
     96	    013D  51				 push cx
     97	    013E  53				 push bx
     98	    013F  50				 push ax
     99
    100	    0140  80 3E	0134r 01		 cmp byte ptr Frame_Active, 1b
    101	    0145  75 40	90 90			 jne @@end_INT08H_StandIn
    102
    103	    0149  8B DC				 mov bx, sp			 ; restore sp value in stack (sp changed due to	    +
    104					 several pushes)
    105	    014B  83 C3	0E			 add bx, 0Eh			 ; 2 * num of pushes after 'push sp'
    106	    014E  8B C3				 mov ax, bx
    107	    0150  05 000E			 add ax, 0Eh			 ; 2 * num of pushes before 'push sp' (including ip,+
    108					 cs, flags)
    109	    0153  36: 89 07			 mov word ptr ss:[bx], ax
    110
    111	    0156  BB B800			 mov bx, VideoMemSegment	 ; set es to the beginnig of video mem segment
    112	    0159  8E C3				 mov es, bx
    113
    114					 ; Displaying registers	values------------------------------
Turbo Assembler	 Version 4.1	    02/27/25 14:57:37	    Page 3
interr~1.asm



    115
    116	    015B  E8 006E			 call MakeFrame
    117
    118	    015E  BB 01B5r			 mov bx, offset	RegValuesOff
    119	    0161  2E: 8B 3F			 mov word ptr di, cs:[bx]
    120
    121	    0164  8B DC				 mov bx, sp
    122	    0166  4B				 dec bx
    123	    0167  4B				 dec bx				 ; to compensate bx+2 before every iteration
    124	    0168  33 C9				 xor cx, cx
    125
    126	    016A  B5 0D				 mov ch, DisplayedRegNum
    127	    016C			 @@for_cond_check:
    128
    129	    016C  3A CD				 cmp cl, ch			 ; for (cl = 0;	cl < (ch = DisplayedRegNum); cl++)
    130	    016E  74 17	90 90			 je  @@for_end
    131
    132	    0172  83 C3	02			 add bx, RegSize		 ; bx += Regsize
    133	    0175  36: 8B 07			 mov ax, word ptr ss:[bx]	 ; ax =	ss:[bx]
    134	    0178  81 C7	00A0			 add di, 0A0h			 ; di += 10
    135
    136	    017C  53				 push bx
    137	    017D  51				 push cx
    138	    017E  E8 0135			 call itoa_hex			 ; display ax value in videomem
    139	    0181  59				 pop cx
    140	    0182  5B				 pop bx
    141
    142	    0183  FE C1				 inc cl				 ; cl++
    143	    0185  EB E5				 jmp @@for_cond_check
    144
    145	    0187			 @@for_end:
    146
    147	    0187			 @@end_INT08H_StandIn:
    148
    149	    0187  58				 pop ax
    150	    0188  5B				 pop bx
    151	    0189  59				 pop cx
    152	    018A  5A				 pop dx
    153
    154	    018B  5E				 pop si
    155	    018C  5F				 pop di
    156
    157	    018D  5D				 pop bp
    158	    018E  1F				 pop ds				 ; do not pop sp!!! - there is stored sp of	    +
    159					 interrupted function
    160	    018F  1F				 pop ds
    161	    0190  07				 pop es
    162	    0191  17				 pop ss
    163
    164	    0192  EA				 JMP_code
    165	    0193  0000			 old_int8_ofs:	 dw 0
    166	    0195  0000			 old_int8_seg:	 dw 0
    167
    168	    0197				 endp
    169
    170					 ;===========================================================================================
    171					 ==================
Turbo Assembler	 Version 4.1	    02/27/25 14:57:37	    Page 4
interr~1.asm



    172					 ; Calculate and save start es:[di] position of	frame and register values displaying
    173					 ; assuming es = B800h (Video Memory Segment)
    174					 ; Entry:    None
    175					 ; Exit:     None
    176					 ; Destr:    ax
    177					 ;===========================================================================================
    178					 ==================
    179	    0197			 PrepareToDisplay	 proc
    180
    181
    182	    0197  BB B800			 mov bx, VideoMemSegment     ; set es to the beginnig of video mem segment
    183	    019A  8E C3				 mov es, bx
    184
    185	    019C  B9 0009			 mov cx, FrameLength
    186	    019F  BA 000F			 mov dx, FrameHeight
    187
    188	    01A2  E8 009C			 call CalcFrameStart	     ; Position	for centered frame
    189
    190	    01A5  2E: 89 3E 01B3r		 mov word ptr cs:[offset FrameOff], di
    191
    192	    01AA  83 C7	0E			 add di, 0Eh	 ; 8 + 6
    193	    01AD  2E: 89 3E 01B5r		 mov word ptr cs:[offset RegValuesOff],	di
    194
    195	    01B2  C3				 ret
    196	    01B3				 endp
    197
    198	    01B3  0000			 FrameOff:	 dw 0	; frame	start position in VideoMemSeg
    199	    01B5  0000			 RegValuesOff:	 dw 0	; start	position in VideoMemSeg	for writing registers values
    200
    201					 ;===========================================================================================
    202					 ==================
    203					 ; Erase frame displayed on es:[offset FrameOff], filling with '0h', '20h' - space char	on  +
    204					 black
    205					 ; Entry:    None
    206					 ; Exit:     None
    207					 ; Destr:    ax
    208					 ;===========================================================================================
    209					 ==================
    210	    01B7			 EraseFrame	 proc
    211
    212	    01B7  BB 01B3r			 mov bx, offset	FrameOff
    213	    01BA  2E: 8B 3F			 mov word ptr di, cs:[bx]
    214
    215	    01BD  BE 0203r			 mov si, offset	Sequence + 9	 ; empty space seq
    216	    01C0  32 E4				 xor ah, ah			 ; set background color	to black
    217
    218	    01C2  B9 0009			 mov cx, FrameLength
    219	    01C5  BA 000F			 mov dx, FrameHeight
    220
    221	    01C8  E8 0097			 call DrawFrame
    222
    223	    01CB  C3				 ret
    224	    01CC				 endp
    225
    226					 ;===========================================================================================
    227					 ==================
    228					 ; Makes a frame for displaying	registers values in video memory or erases it if already    +
Turbo Assembler	 Version 4.1	    02/27/25 14:57:37	    Page 5
interr~1.asm



    229					 displaying
    230					 ; FrameLength and FrameHeight are set as const
    231					 ; Position for	frame (centered) is calculated before going resident
    232					 ;
    233					 ; !!! MAKE SURE THAT REGNAME ENDS WITH	DOUBLE '0Dh' !!!
    234					 ;
    235					 ; Entry:    None
    236					 ; Exit:     None
    237					 ; Destr:    ax
    238					 ;===========================================================================================
    239					 ==================
    240	    01CC			 MakeFrame   proc
    241
    242	    01CC  BB B800			 mov bx, VideoMemSegment     ; set es to the beginnig of video mem segment
    243	    01CF  8E C3				 mov es, bx
    244
    245					 ; Drawing Frame--------------------------------------------
    246
    247
    248	    01D1  BB 01B3r			 mov bx, offset	FrameOff	 ; load	precalculated frame offset
    249	    01D4  2E: 8B 3F			 mov word ptr di, cs:[bx]
    250	    01D7  57				 push di
    251
    252	    01D8  BE 01FAr			 mov si, offset	Sequence
    253	    01DB  B4 03				 mov ah, 03h
    254
    255	    01DD  B9 0009			 mov cx, FrameLength
    256	    01E0  BA 000F			 mov dx, FrameHeight
    257
    258	    01E3  E8 007C			 call DrawFrame
    259
    260	    01E6  5F				 pop di
    261					 ; Write registers names------------------------------------
    262
    263						 ; di will be shifted to the begining of the first string for first WriteString
    264	    01E7  83 C7	08			 add di, 08h
    265	    01EA  BE 020Cr			 mov si, offset	RegName
    266
    267	    01ED			 @@loop:
    268	    01ED  81 C7	009A			 add di, 09Ah		 ; considering length_of_strings = 3, di_shift = 160 - 3 * 2
    269	    01F1  E8 00AD			 call WriteString
    270
    271	    01F4  2E: 38 0C			 cmp cs:[si], cl	 ; after WriteString 0Dh stored	in cl
    272	    01F7  75 F4				 jne @@loop		 ; writing strings until '0Dh',	'0Dh' is met
    273
    274	    01F9  C3				 ret
    275	    01FA				 endp
    276
    277	    01FA  C9 CD	BB BA 20 BA C8+	 Sequence:   db	 0c9h, 0cdh, 0bbh, 0bah, 020h, 0bah, 0c8h, 0cdh, 0bch	 ; double line box
    278		  CD BC
    279	    0203  20 20	20 20 20 20 20+		     db	 020h, 020h, 020h, 020h, 020h, 020h, 020h, 020h, 020h	 ; empty black space
    280		  20 20
    281
    282	    020C  61 78	3A 0D 62 78 3A+	 RegName:    db	 'ax:',	0Dh, 'bx:', 0Dh, 'cx:',	0Dh, 'dx:', 0Dh, 'si:',	0Dh
    283		  0D 63	78 3A 0D 64 78+
    284		  3A 0D	73 69 3A 0D
    285	    0220  64 69	3A 0D 62 70 3A+		     db	 'di:',	0Dh, 'bp:', 0Dh, 'sp:',	0Dh, 'ds:', 0Dh, 'es:',	0Dh
Turbo Assembler	 Version 4.1	    02/27/25 14:57:37	    Page 6
interr~1.asm



    286		  0D 73	70 3A 0D 64 73+
    287		  3A 0D	65 73 3A 0D
    288	    0234  73 73	3A 0D 69 70 3A+		     db	 'ss:',	0Dh, 'ip:', 0Dh, 'cs:',	0Dh, 0Dh ; !!! MAKE SURE IT ENDS WITH DOUBLE+
    289		  0D 63	73 3A 0D 0D	 'ODh' !!!
    290
    291					 ;===========================================================================================
    292					 ==================
    293					 ; Calculates the start	position for a frame in	video mem
    294					 ; Entry:    cx	- length of the	frame
    295					 ;	     dx	- height of the	frame
    296					 ; Exit:     di	- pointer to a start position
    297					 ; Destr:    ax
    298					 ;===========================================================================================
    299					 ==================
    300	    0241			 CalcFrameStart	 proc
    301
    302	    0241  51				 push cx
    303	    0242  52				 push dx
    304	    0243  8B C2				 mov ax, dx
    305
    306						 ; di =	(80 - cx / 2 + 160 * (14 - dx /	2)) / 2	* 2
    307	    0245  D1 E8				 shr ax, 1
    308
    309	    0247  BF 0050			 mov di, 0050h
    310	    024A  2B F9				 sub di, cx
    311
    312	    024C  2D 000E			 sub ax, 0Eh
    313	    024F  F7 D8				 neg ax
    314	    0251  C1 E0	05			 shl ax, 5
    315
    316	    0254  B9 0005			 mov cx, 05h
    317	    0257  F7 E1				 mul cx
    318
    319	    0259  03 F8				 add di, ax
    320
    321	    025B  D1 EF				 shr di, 1		 ; round to a multiple of 2 (for video memory)
    322	    025D  D1 E7				 shl di, 1
    323
    324	    025F  5A				 pop dx
    325	    0260  59				 pop cx
    326
    327	    0261  C3				 ret
    328	    0262				 endp
    329
    330
    331					 ;===========================================================================================
    332					 ==================
    333					 ; Draws a frame in video mem described	with 9 bytes
    334					 ; Entry:    ah	- color
    335					 ;	     si	- pointer to 9 byte sequence
    336					 ;	     cx	- length of the	frame
    337					 ;	     dx	- height of the	frame
    338					 ; Exit:     None
    339					 ; Destr:    al, si, di
    340					 ;===========================================================================================
    341					 ==================
    342	    0262			 DrawFrame   proc
Turbo Assembler	 Version 4.1	    02/27/25 14:57:37	    Page 7
interr~1.asm



    343
    344	    0262  52				 push dx
    345	    0263  1E				 push ds
    346	    0264  8C CB				 mov bx, cs
    347	    0266  8E DB				 mov ds, bx
    348
    349	    0268  E8 001D			 call DrawLine
    350	    026B  83 C6	03			 add si, 03h		 ; move	to the next subsequence
    351
    352	    026E  FE CA				 dec dl
    353	    0270  FE CA				 dec dl
    354	    0272			 height:
    355	    0272  E8 0013			 call DrawLine
    356	    0275  FE CA				 dec dl
    357	    0277  80 FA	00			 cmp dl, 0h
    358	    027A  77 F6				 ja height
    359
    360	    027C  83 C6	03			 add si, 03h
    361
    362	    027F  E8 0006			 call DrawLine
    363	    0282  83 C6	03			 add si, 03h
    364
    365	    0285  1F				 pop ds
    366	    0286  5A				 pop dx
    367
    368	    0287  C3				 ret
    369	    0288				 endp
    370
    371					 ;===========================================================================================
    372					 ==================
    373					 ; Draws line described	with 3 bytes in	video mem
    374					 ; 1 time first	byte, (cx-2) times - second byte and then third	byte
    375					 ; 121 (cx = 6)	=> 122221
    376					 ; Entry:    ah	- color
    377					 ;	     si	- pointer to 3 byte sequence
    378					 ;	     cx	- length of the	frame
    379					 ; Exit:     None
    380					 ; Destr:    al, di
    381					 ;===========================================================================================
    382					 ==================
    383	    0288			 DrawLine    proc
    384
    385	    0288  56				 push si	 ; save	si
    386	    0289  51				 push cx	 ; save	cx
    387
    388	    028A  49				 dec cx
    389	    028B  49				 dec cx
    390
    391	    028C  FC				 cld
    392	    028D  AC				 lodsb		 ; reading first byte of sequence to al
    393	    028E  AB				 stosw		 ; writing to video mem
    394
    395	    028F  AC				 lodsb		 ; reading second byte
    396	    0290  F3> AB			 rep stosw	 ; writing (cx - 2) times to video mem
    397
    398	    0292  AC				 lodsb		 ; reading first byte of sequence to al
    399	    0293  AB				 stosw		 ; writing to video mem
Turbo Assembler	 Version 4.1	    02/27/25 14:57:37	    Page 8
interr~1.asm



    400
    401	    0294  59				 pop cx		 ; save	cx
    402
    403	    0295  D1 E1				 shl cx, 1	 ; shift di to the beginning of	the next string
    404	    0297  81 C7	00A0			 add di, 0A0h
    405	    029B  2B F9				 sub di, cx
    406	    029D  D1 E9				 shr cx, 1
    407
    408	    029F  5E				 pop si		 ; save	si
    409
    410	    02A0  C3				 ret
    411	    02A1				 endp
    412
    413					 ;===========================================================================================
    414					 ==================
    415					 ; Writes a string ending with '\r' in video mem (could	be set in cl - look in func)
    416					 ; Entry:    ah	- color
    417					 ;	     si	- pointer to a string
    418					 ;	     di	- pointer to video mem for beginning of	the string
    419					 ; Exit:     None
    420					 ; Destr:    cx, si, di
    421					 ;===========================================================================================
    422					 ==================
    423	    02A1			 WriteString proc
    424
    425	    02A1  1E				 push ds
    426	    02A2  8C CB				 mov bx, cs
    427	    02A4  8E DB				 mov ds, bx
    428
    429	    02A6  B1 0D				 mov cl, 0Dh		 ; TERMINATING SYMBOL
    430
    431	    02A8			 @@test_condition:
    432	    02A8  2E: 38 0C			 cmp cs:[si], cl	 ; while (ds:[si] != cl)
    433	    02AB  74 06	90 90			 je while_end
    434
    435	    02AF  AC				 lodsb			 ; al =	ds:[si++]
    436	    02B0  AB				 stosw			 ; es:[di] = ax, di+=2
    437	    02B1  EB F5				 jmp @@test_condition
    438
    439	    02B3			 while_end:
    440
    441	    02B3  46				 inc si
    442	    02B4  1F				 pop ds
    443
    444	    02B5  C3				 ret
    445	    02B6				 endp
    446
    447					 ;===========================================================================================
    448					 ==================
    449					 ; Reads 16-based number from 0	to 255 from a string and saves to al
    450					 ; Entry:    di	- pointer to a string to write a number
    451					 ;	     ax	- value	to translate
    452					 ; Exit:     None
    453					 ; Destr:    di, si, ax, bx, cx
    454					 ;===========================================================================================
    455					 ==================
    456	    02B6			 itoa_hex    proc
Turbo Assembler	 Version 4.1	    02/27/25 14:57:37	    Page 9
interr~1.asm



    457
    458	    02B6  57				 push di
    459
    460						 ; bx =	ax // 16
    461						 ; for (i =0; i	< 4; i++) { es:[di] = ax % 16, ax = ax // 16}
    462
    463	    02B7  33 C9				 xor cx, cx
    464	    02B9  B5 04				 mov ch, RegSize * 2
    465	    02BB  BE 02E7r			 mov si, offset	HexASCII
    466
    467	    02BE			 @@for_cond_check:
    468
    469	    02BE  3A CD				 cmp cl, ch
    470	    02C0  74 23	90 90			 je  @@for_end
    471
    472	    02C4  8B D8				 mov bx, ax
    473	    02C6  C1 EB	04			 shr bx, 4
    474	    02C9  C1 E3	04			 shl bx, 4
    475
    476	    02CC  56				 push si
    477
    478	    02CD  03 F0				 add si, ax
    479	    02CF  2B F3				 sub si, bx
    480
    481	    02D1  2B C3				 sub ax, bx
    482	    02D3  2E: 8A 04			 mov byte ptr al, cs:[si]
    483	    02D6  26: 88 05			 mov byte ptr es:[di], al
    484	    02D9  4F				 dec di
    485	    02DA  4F				 dec di
    486	    02DB  5E				 pop si
    487
    488	    02DC  8B C3				 mov ax, bx
    489	    02DE  C1 E8	04			 shr ax, 4
    490	    02E1  FE C1				 inc cl
    491	    02E3  EB D9				 jmp @@for_cond_check
    492
    493	    02E5			 @@for_end:
    494
    495	    02E5  5F				 pop di
    496
    497	    02E6  C3				 ret
    498	    02E7				 endp
    499
    500
    501	    02E7  30 31	32 33 34 35 36+	 HexASCII:   db	'0', '1', '2', '3', '4', '5', '6', '7'
    502		  37
    503	    02EF  38 39	41 42 43 44 45+		     db	'8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
    504		  46
    505
    506	    02F7  00			 EOP:	 db 0
    507
    508	    02F8			 Main	 proc
    509
    510
    511					 ; Rewriting INT09H in Table of								    +
    512					 Interruptions-----------------------------------------------------------
    513
Turbo Assembler	 Version 4.1	    02/27/25 14:57:37	    Page 10
interr~1.asm



    514					     ; set es[bx] to a INT09H pointer
    515	    02F8  33 C0				 xor ax, ax
    516	    02FA  8E C0				 mov es, ax
    517	    02FC  B9 1234			 mov cx, 1234h
    518	    02FF  BA 5678			 mov dx, 5678h
    519	    0302  BB 0024			 mov bx, 09h * 04h
    520
    521					     ; Save old	handler	of INT09H
    522	    0305  26: 8B 07			 mov ax, es:[bx]
    523	    0308  A3 0130r			 mov word ptr old_int9_ofs, ax
    524	    030B  26: 8B 47 02			 mov ax, es:[bx+2]
    525	    030F  A3 0132r			 mov word ptr old_int9_seg, ax
    526
    527					     ; write new handler for INT09H
    528					     ; Forbid interrupts to avoid trying to handle interruption	with wrong function address
    529	    0312  FA				 cli
    530	    0313  26: C7 07 0103r		 mov es:[bx], offset INT09H_StandIn
*Warning* interr~1.asm(495) Argument needs type	override
    531	    0318  0E				 push cs
    532	    0319  58				 pop ax
    533	    031A  26: 89 47 02			 mov es:[bx+2],	ax
    534	    031E  FB				 sti
    535
    536						 ;int 09h
    537					 ; Rewriting INT08H in Table of								    +
    538					 Interruptions-----------------------------------------------------------
    539
    540					     ; set es[bx] to a INT08H pointer
    541	    031F  33 C0				 xor ax, ax
    542	    0321  8E C0				 mov es, ax
    543	    0323  BB 0020			 mov bx, 08h * 04h
    544
    545					     ; Save old	handler	of INT08H
    546	    0326  26: 8B 07			 mov ax, es:[bx]
    547	    0329  A3 0193r			 mov word ptr old_int8_ofs, ax
    548	    032C  26: 8B 47 02			 mov ax, es:[bx+2]
    549	    0330  A3 0195r			 mov word ptr old_int8_seg, ax
    550
    551					     ; write new handler for INT08H
    552					     ; Forbid interrupts to avoid trying to handle interruption	with wrong function address
    553	    0333  FA				 cli
    554	    0334  26: C7 07 0135r		 mov es:[bx], offset INT08H_StandIn
*Warning* interr~1.asm(518) Argument needs type	override
    555	    0339  0E				 push cs
    556	    033A  58				 pop ax
    557	    033B  26: 89 47 02			 mov es:[bx+2],	ax
    558	    033F  FB				 sti
    559
    560	    0340  E8 FE54			 call PrepareToDisplay
    561
    562					 ; Terminate and Stay									    +
    563					 Resident--------------------------------------------------------------------------
    564	    0343  B8 3100			 mov ax, 3100h		 ; TSR
    565	    0346  BA 02F7r			 mov dx, offset	EOP	 ; programm size in paragraphs (16 byte)
    566	    0349  C1 EA	04			 shr dx, 4
    567	    034C  42				 inc dx
    568	    034D  CD 21				 int 21h
Turbo Assembler	 Version 4.1	    02/27/25 14:57:37	    Page 11
interr~1.asm



    569
    570	    034F				 endp
    571
    572					 end	 Start
Turbo Assembler	 Version 4.1	    02/27/25 14:57:37	    Page 12
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "02/27/25"
??FILENAME			  Text	 "interr~1"
??TIME				  Text	 "14:57:37"
??VERSION			  Number 040A
@32BIT				  Text	 0
@@END_INT08H_STANDIN		  Near	 DGROUP:0187
@@FOR_COND_CHECK		  Near	 DGROUP:016C
@@FOR_COND_CHECK		  Near	 DGROUP:02BE
@@FOR_END			  Near	 DGROUP:0187
@@FOR_END			  Near	 DGROUP:02E5
@@LOOP				  Near	 DGROUP:01ED
@@NOT_ACTIVE			  Near	 DGROUP:0127
@@TEST_CONDITION		  Near	 DGROUP:02A8
@CODE				  Text	 DGROUP
@CODESIZE			  Text	 0
@CPU				  Text	 0F0FH
@CURSEG				  Text	 _TEXT
@DATA				  Text	 DGROUP
@DATASIZE			  Text	 0
@FILENAME			  Text	 INTERR~1
@INTERFACE			  Text	 000H
@MODEL				  Text	 1
@STACK				  Text	 DGROUP
@WORDSIZE			  Text	 4
CALCFRAMESTART			  Near	 DGROUP:0241
DISPLAYEDREGNUM			  Number 000D
DRAWFRAME			  Near	 DGROUP:0262
DRAWLINE			  Near	 DGROUP:0288
END_INT09H_STANDIN		  Near	 DGROUP:012C
EOP				  Near	 DGROUP:02F7
ERASEFRAME			  Near	 DGROUP:01B7
FRAMECOLOR			  Number 0003
FRAMEHEIGHT			  Number 000F
FRAMELENGTH			  Number 0009
FRAMEOFF			  Near	 DGROUP:01B3
FRAME_ACTIVE			  Near	 DGROUP:0134
HEIGHT				  Near	 DGROUP:0272
HEXASCII			  Near	 DGROUP:02E7
INT08H_STANDIN			  Near	 DGROUP:0135
INT09H_STANDIN			  Near	 DGROUP:0103
ITOA_HEX			  Near	 DGROUP:02B6
JMP_CODE			  Text	 db 0eah
KEYBOARDPORT			  Number 0060
MAIN				  Near	 DGROUP:02F8
MAKEFRAME			  Near	 DGROUP:01CC
OLD_INT8_OFS			  Near	 DGROUP:0193
OLD_INT8_SEG			  Near	 DGROUP:0195
OLD_INT9_OFS			  Near	 DGROUP:0130
OLD_INT9_SEG			  Near	 DGROUP:0132
PREPARETODISPLAY		  Near	 DGROUP:0197
REGNAME				  Near	 DGROUP:020C
REGSIZE				  Number 0002
REGVALUESOFF			  Near	 DGROUP:01B5
R_SCAN_CODE			  Number 0013
Turbo Assembler	 Version 4.1	    02/27/25 14:57:37	    Page 13
Symbol Table



SEQUENCE			  Near	 DGROUP:01FA
START				  Near	 DGROUP:0100
VIDEOMEMSEGMENT			  Number B800
WHILE_END			  Near	 DGROUP:02B3
WRITESTRING			  Near	 DGROUP:02A1

Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  _DATA				  16  0000 Word	  Public  DATA
  _TEXT				  16  034F Word	  Public  CODE
Turbo Assembler	 Version 4.1	    02/27/25 14:57:37	    Page 14
Error Summary



*Warning* interr~1.asm(495) Argument needs type	override
*Warning* interr~1.asm(518) Argument needs type	override
